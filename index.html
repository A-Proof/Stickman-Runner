<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Stickman Runner</title>
<style>
  html,body{height:100%;margin:0;background:linear-gradient(#87CEEB,#dfefff);}
  canvas{display:block;margin:0 auto;background:linear-gradient(#b3e0ff,#ffffff);box-shadow:0 8px 30px rgba(0,0,0,0.15);border-radius:10px;}
  #ui{position:fixed;left:10px;top:10px;font-family:Inter,system-ui,Segoe UI,Arial;background:rgba(255,255,255,0.8);padding:8px 10px;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.08);}
  #message{position:fixed;left:50%;transform:translateX(-50%);bottom:30px;background:rgba(0,0,0,0.7);color:white;padding:10px 16px;border-radius:10px;font-family:Arial;display:none;}
  button{margin-left:6px;padding:6px 8px;border-radius:6px;border:0;background:#0077ff;color:white;cursor:pointer;}
  footer{position:fixed;right:10px;bottom:10px;color:#333;font-family:Arial;font-size:12px;opacity:0.8}
</style>
</head>
<body>
<div id="ui">
  <strong>Stickman Runner</strong>
  <span style="margin-left:10px;color:#555">Use ← → to move, ↑ or Space to jump</span>
  <button id="restart">Restart</button>
</div>
<canvas id="game" width="900" height="540"></canvas>
<div id="message"></div>
<footer>Collect the breathing elements — they pulse and say a message.</footer>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d', { alpha: false });
  const W = canvas.width, H = canvas.height;

  // GAME STATE
  let keys = {};
  let gravity = 0.9;
  let friction = 0.85;

  // Player (stickman)
  const player = {
    x: 80, y: 360,
    vx: 0, vy: 0,
    w: 22, h: 44,
    onGround: false,
    facing: 1,
    color: '#111'
  };

  // Platforms (x, y, w, h)
  let platforms = [
    {x:0,y:500,w:900,h:40}, // ground
    {x:180,y:420,w:140,h:14},
    {x:350,y:360,w:120,h:14},
    {x:520,y:300,w:140,h:14},
    {x:700,y:240,w:160,h:14}
  ];

  // Breathing elements (floating objects) - they pulse (breathe) and display the phrase
  let breathers = [
    {x:260,y:380,r:18,offset:0.0, collected:false},
    {x:560,y:260,r:20,offset:1.2, collected:false},
    {x:760,y:200,r:22,offset:2.0, collected:false}
  ];

  // Camera
  let camX = 0;

  // UI message
  const messageEl = document.getElementById('message');
  let msgTimer = 0;

  // Input
  window.addEventListener('keydown', e => {
    keys[e.key.toLowerCase()] = true;
    if (['arrowup',' '].includes(e.key.toLowerCase())) e.preventDefault();
  });
  window.addEventListener('keyup', e => {
    keys[e.key.toLowerCase()] = false;
  });
  document.getElementById('restart').addEventListener('click', resetGame);

  // Reset
  function resetGame(){
    player.x = 80; player.y = 360; player.vx = 0; player.vy = 0;
    breathers.forEach(b => b.collected = false);
    camX = 0;
    showMessage('Good luck!');
  }

  // Show temporary message
  function showMessage(txt, time = 2000){
    messageEl.textContent = txt;
    messageEl.style.display = 'block';
    msgTimer = time;
  }

  // Collision helper
  function rectIntersect(a, b) {
    return (a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + b.h && a.y + a.h > b.y);
  }

  // Game loop
  function update(dt){
    // Input accel
    const acc = 0.8;
    if (keys['arrowleft'] || keys['a']) { player.vx -= acc; player.facing = -1; }
    if (keys['arrowright'] || keys['d']) { player.vx += acc; player.facing = 1; }

    // Jump
    if ((keys['arrowup'] || keys['w'] || keys[' ']) && player.onGround) {
      player.vy = -18;
      player.onGround = false;
    }

    // Physics
    player.vy += gravity * (dt/16);
    player.x += player.vx * (dt/16);
    player.y += player.vy * (dt/16);

    // Friction when on ground
    if (player.onGround) player.vx *= friction;
    else player.vx *= 0.995;

    // Bounds
    if (player.x < -50) player.x = -50;
    if (player.x > 3000) player.x = 3000;

    // Collision with platforms (simple AABB with vertical correction)
    player.onGround = false;
    for (let p of platforms) {
      const plat = {x: p.x, y: p.y, w: p.w, h: p.h};
      const playerBox = {x: player.x, y: player.y, w: player.w, h: player.h};
      if (rectIntersect(playerBox, plat)) {
        // Determine overlap
        const overlapY = (player.y + player.h) - plat.y;
        const overlapTop = plat.y + plat.h - player.y;
        // Basic resolution: if coming from above, put on top
        if (player.vy >= 0 && player.y + player.h - player.vy <= plat.y + 2) {
          player.y = plat.y - player.h;
          player.vy = 0;
          player.onGround = true;
        } else {
          // Side correction: push out horizontally
          if (player.x + player.w/2 < plat.x + plat.w/2) {
            player.x = plat.x - player.w - 0.1;
            player.vx *= -0.2;
          } else {
            player.x = plat.x + plat.w + 0.1;
            player.vx *= -0.2;
          }
        }
      }
    }

    // Breather interaction + pulsing animation timers
    const t = performance.now() / 1000;
    for (let b of breathers) {
      if (b.collected) continue;
      const pulse = 1 + Math.sin(t * 2 + (b.offset||0)) * 0.15;
      const dx = (player.x + player.w/2) - b.x;
      const dy = (player.y + player.h/2) - b.y;
      const dist = Math.hypot(dx, dy);
      if (dist < b.r * pulse + 14) {
        b.collected = true;
        showMessage('"I am cool, and follow the lord!" — collected', 3000);
      }
    }

    // Camera: follow player with easing
    const targetCam = player.x - 180;
    camX += (targetCam - camX) * 0.08;

    // message timer
    if (msgTimer > 0) {
      msgTimer -= dt;
      if (msgTimer <= 0) messageEl.style.display = 'none';
    }
  }

  // Stickman drawing
  function drawStickman(cx, cy, facing, scale=1, color='#111') {
    ctx.save();
    ctx.translate(cx, cy);
    ctx.scale(scale, scale);
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    ctx.lineCap = 'round';

    // head
    ctx.beginPath();
    ctx.arc(0, -18, 8, 0, Math.PI*2);
    ctx.stroke();

    // body
    ctx.beginPath();
    ctx.moveTo(0, -10);
    ctx.lineTo(0, 14);
    ctx.stroke();

    // arms
    ctx.beginPath();
    ctx.moveTo(0, -2);
    ctx.lineTo(-10 * facing, 8);
    ctx.moveTo(0, -2);
    ctx.lineTo(10 * facing, 8);
    ctx.stroke();

    // legs
    ctx.beginPath();
    ctx.moveTo(0, 14);
    ctx.lineTo(-12, 30);
    ctx.moveTo(0, 14);
    ctx.lineTo(12, 30);
    ctx.stroke();

    ctx.restore();
  }

  // Draw breathing element
  function drawBreather(b, t){
    if (b.collected) {
      // faint floating away effect
      const y = b.y - 30;
      ctx.save();
      ctx.globalAlpha = 0.25;
      ctx.beginPath();
      ctx.arc(b.x - camX, y, 14, 0, Math.PI*2);
      ctx.fillStyle = '#a3c6ff';
      ctx.fill();
      ctx.restore();
      return;
    }
    const pulse = 1 + Math.sin(t * 2 + (b.offset||0)) * 0.15;
    const r = b.r * pulse;
    // glow
    ctx.save();
    const gx = ctx.createRadialGradient(b.x - camX, b.y, r*0.2, b.x - camX, b.y, r*2.5);
    gx.addColorStop(0, 'rgba(255,230,200,0.9)');
    gx.addColorStop(0.6, 'rgba(170,200,255,0.25)');
    gx.addColorStop(1, 'rgba(120,160,255,0)');
    ctx.fillStyle = gx;
    ctx.beginPath();
    ctx.arc(b.x - camX, b.y, r*2.2, 0, Math.PI*2);
    ctx.fill();

    // core circle
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.arc(b.x - camX, b.y, r*0.9, 0, Math.PI*2);
    ctx.fill();

    // outer ring
    ctx.beginPath();
    ctx.lineWidth = 3;
    ctx.strokeStyle = '#1d63ff';
    ctx.arc(b.x - camX, b.y, r, 0, Math.PI*2);
    ctx.stroke();
    ctx.restore();

    // breathing text that pulses with it
    const alpha = 0.4 + 0.6 * (0.5 + 0.5 * Math.sin(t*2 + (b.offset||0)));
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.font = '14px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillStyle = '#052b6b';
    ctx.fillText('I am cool,', b.x - camX, b.y - r - 18);
    ctx.fillText('and follow the lord!', b.x - camX, b.y - r + 0);
    ctx.restore();
  }

  // Draw UI and scene
  function render(){
    // clear
    ctx.fillStyle = '#bfe9ff';
    ctx.fillRect(0,0,W,H);

    // sky decor
    for (let i = 0; i < 6; i++) {
      const cx = (i*200 - (camX*0.2 % 200));
      ctx.fillStyle = 'rgba(255,255,255,0.18)';
      ctx.beginPath();
      ctx.ellipse(cx + 60, 90 + Math.sin(i + camX*0.004)*8, 60, 22, 0, 0, Math.PI*2);
      ctx.fill();
    }

    // parallax mountains
    ctx.save();
    ctx.translate(-camX * 0.3, 0);
    ctx.fillStyle = '#d0e8ff';
    ctx.beginPath();
    ctx.moveTo(-400, H);
    ctx.lineTo(120, 220);
    ctx.lineTo(420, H);
    ctx.lineTo(900, H);
    ctx.fill();
    ctx.restore();

    // platforms
    ctx.save();
    ctx.translate(-camX, 0);
    for (let p of platforms) {
      // platform shadow
      ctx.fillStyle = 'rgba(0,0,0,0.08)';
      ctx.fillRect(p.x + 6, p.y + 6, p.w, p.h);
      // platform top
      ctx.fillStyle = '#3a6b9a';
      ctx.fillRect(p.x, p.y, p.w, p.h);
      // trim
      ctx.fillStyle = '#7fb0df';
      ctx.fillRect(p.x, p.y, p.w, 4);
    }

    // breathers
    const now = performance.now()/1000;
    for (let b of breathers) drawBreather(b, now);

    // stickman (player)
    drawStickman(player.x + player.w/2 - camX, player.y + 8, player.facing, 1.1, player.color);

    ctx.restore();

    // HUD: collected count
    const collectedCount = breathers.filter(b => b.collected).length;
    ctx.save();
    ctx.font = '14px Arial';
    ctx.fillStyle = '#012a53';
    ctx.fillText(`Breathers: ${collectedCount} / ${breathers.length}`, 16, 26);
    ctx.restore();

    // Win text
    if (collectedCount === breathers.length) {
      ctx.save();
      ctx.globalAlpha = 0.95;
      ctx.fillStyle = 'rgba(0,0,0,0.6)';
      ctx.fillRect(W/2 - 220, H/2 - 60, 440, 120);
      ctx.fillStyle = '#fff';
      ctx.font = '28px system-ui, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('You collected them all!', W/2, H/2 - 6);
      ctx.font = '16px system-ui, Arial';
      ctx.fillText('Thanks for playing Stickman Runner', W/2, H/2 + 22);
      ctx.restore();
    }
  }

  // Loop with delta time
  let last = performance.now();
  function loop(now) {
    const dt = now - last;
    last = now;
    update(dt);
    render();
    requestAnimationFrame(loop);
  }

  // Kick off
  resetGame();
  requestAnimationFrame(loop);

  // friendly touch: click to nudge
  canvas.addEventListener('click', e => {
    const rect = canvas.getBoundingClientRect();
    const mx = e.clientX - rect.left + camX;
    const my = e.clientY - rect.top;
    // small impulse towards click
    const dx = mx - (player.x + player.w/2);
    player.vx += Math.sign(dx) * 6;
  });
})();
</script>
</body>
</html>
